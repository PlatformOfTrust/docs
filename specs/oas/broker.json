{
  "swagger": "2.0",
  "info": {
    "title": "Broker",
    "description": "The Broker API provides means to connect a service to a translator that will\nreturn desired data from different sources. The data broker does not mangle\nthe data in any way, it only functions as a proxy between services and\ntranslators.\n",
    "version": "v1"
  },
  "host": "api-sandbox.oftrust.net",
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "definitions": {
    "data-product-request": {
      "type": "object",
      "properties": {
        "@context": {
          "description": "A URL for the parameters context",
          "example": "https://standards.oftrust.net/v2/Context/DataProductParameters/Sensor",
          "type": "string"
        },
        "timestamp": {
          "description": "A timestamp in RFC3339 format",
          "example": "2018-11-01T12:00:00+00:00",
          "type": "string"
        },
        "productCode": {
          "description": "The data product's product code",
          "example": "product-1",
          "type": "string"
        },
        "parameters": {
          "description": "Additional parameters to be sent to the translator",
          "example": {
            "param-1": "param-1 value",
            "param-2": "param-2 value"
          },
          "type": "object"
        }
      },
      "required": [
        "timestamp",
        "productCode",
        "parameters"
      ]
    }
  },
  "paths": {
    "/broker/{version}/fetch-data-product": {
      "post": {
        "description": "<p>\nRequest data from an external data source defined by the data product. The data\nbroker will validate the signature passed to the broker in the header\n`X-Pot-Signature`. See the parameter info for more info on how to generate\nthis signature.\n</p>\n\n<p>\nOnce the signature is validated, the request is passed on to the translator on\nthe URL defined in the data product (`translatorUrl`).\n</p>\n\n<p>The data broker will generate it's own signature and pass it along in the\n`X-Pot-Signature` header. The translator must now validate that the request\ncame from the data broker: (example in Python)<br />\n\n<code>\nbody = {...}\nsignature_value = request.headers.get(\"x-pot-signature\")\nbody_string = json.dumps(<br />\n  body, sort_keys=True, indent=None, separators=(',', ': ')<br />\n).strip()<br />\nrsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />\nkey = rsa_algo.prepare_key(broker_public_key) <br />\nis_valid = rsa_algo.verify(body_string.encode(\"utf-8\"), key, signature_value)\n</code>\n</p>\n\n<p>Once the translator has validated the signature and verified that the\ntimestamp passed in the body is +/- 5 seconds, it can proceed to fetch the\ninformation from the third party data source, or wherever the data is hosted\nfor this data product.\n</p>\n\n<p>Once the translator has got the needed data, it must sign the data with\nit's own private key (corresponding public key must be specified in the data\nproduct's `organizationPublicKeys` list) and return the data to the data broker.\nThe data to be signed, is the `data` key in the response, e.g.\n<code>\n{<br />\n  \"@context\": \"https://standards.oftrust.net/v2/Context/Identity/Product/DataProduct/\", <br />\n  \"data\": data,  # this is the data that is signed.<br />\n  \"signature\": {<br />\n      \"type\": \"RsaSignature2018\",<br />\n      \"created\": created_at,  # RFC 3339 timestamp<br />\n      \"creator\": \"https://url-to-public-key\",  # Same URL as specified in the data product<br />\n      \"signatureValue\": signature,<br />\n  }<br />\n}\n</code>\n</p>\n\n<p>\nThe signature itself is generated by adding a `__signed__` key to the data to\nbe signed. It's the same RFC 3339 timestamp as when the signature was created.\nExample in Python:<br />\n<code>\nsign_data = copy(data)<br />\nsign_data[\"__signed__\"] = created_at<br />\nsign_string = json.dumps(<br />\n  sign_data, sort_keys=True, indent=None, separators=(',', ': ')<br />\n).strip()<br />\nrsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />\nkey = rsa_algo.prepare_key(translator_private_key) <br />\nsignature = base64.b64encode(<br />\n  rsa_algo.sign(sign_string.encode(\"utf-8\"), key)<br />\n).decode(\"utf-8\")<br />\n</code>\n</p>\n\n<p>For more information read the header/parameter descriptions.</p>\n",
        "operationId": "POST_broker-version-fetch-data-product",
        "responses": {
          "200": {
            "description": "<p><strong>Validating the signature from a translator</strong></p>\n\n<p>\nWhen you validate the signature returned from the translator, remember to\n`base64` decode the signature value from the response, and add the\n`__signed__` date to the payload\nbefore validating the signature, e.g:\n<code>\nsignature_value = base64.b64decode(response[\"signature\"][\"signatureValue\"]) <br />\nsignature_payload = copy.copy(response[\"data\"])  # to not modify the original data. <br />\nsignature_payload[\"__signed__\"] = signature_data[\"created\"] <br />\n</code>\n</p>\n\n<p>When validating the signature, use the same way to get the\nstring-version of the payload as when generating the `X-Pot-Signature`\nheader. Then use the following approach to verify the signature\nreturned:\n<code>\npayload_string = json.dumps(<br />\n  signature_payload, sort_keys=True, indent=None, separators=(',', ': ')<br />\n).strip()<br />\nrsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />\nkey = rsa_algo.prepare_key(public_key) <br />\nis_valid = rsa_algo.verify(payload_string.encode(\"utf-8\"), key, signature_value)\n</code>\n</p>\n",
            "schema": {
              "example": "{\n  \"@context\": \"<context url>\",\n  \"data\": {\n    <response from translator>\n  },\n  \"signature\": {\n    \"type\": \"<signature type>\",\n    \"created\": \"<RFC3339>\",\n    \"creator\": \"<public key URL>\",\n    \"signatureValue\": \"...\"\n  }\n}\n"
            }
          },
          "403": {
            "description": "You don't have permissions to consume this data product!\n",
            "schema": {
              "example": {
                "error": {
                  "status": 403,
                  "message": "You don't have permissions to consume this data product!"
                }
              }
            }
          },
          "422": {
            "description": "Missing data for required field.\n",
            "schema": {
              "example": {
                "error": {
                  "status": 422,
                  "message": {
                    "mandatoryParameter": [
                      "Missing data for required field."
                    ]
                  }
                }
              }
            }
          },
          "500": {
            "description": "The data returned from the translator cannot be read or parsed.\n",
            "schema": {
              "example": {
                "error": {
                  "status": 500,
                  "message": "Could not parse response from translator"
                }
              }
            }
          },
          "502": {
            "description": "Error encountered in the external service.\n",
            "schema": {
              "example": {
                "Any translator error with Content-Type `text/html` or `text/plain`": {
                  "error": {
                    "status": 502,
                    "message": "External translator returns an invalid response.",
                    "translatorResponse": {
                      "status": 422,
                      "data": "Invalid parameters"
                    }
                  }
                },
                "Any translator error with Content-Type `application/json`": {
                  "error": {
                    "status": 502,
                    "message": "External translator returns an invalid response.",
                    "translatorResponse": {
                      "status": 422,
                      "data": {
                        "dataFromTranslatorAsIs": [
                          1,
                          2,
                          3
                        ]
                      }
                    }
                  }
                },
                "Any translator error with Content-Type is something else than defined in previous examples": {
                  "error": {
                    "status": 502,
                    "message": "External translator returns an invalid response.",
                    "translatorResponse": {
                      "status": 422
                    }
                  }
                }
              }
            }
          },
          "504": {
            "description": "The translator takes too long to respond\n",
            "schema": {
              "example": {
                "error": {
                  "status": 504,
                  "message": "External translator takes too long to respond"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "<p>\nA HMAC-SHA256 signature in `base64` encoded format.\nThe signature is created from the request payload and the\napp's client secret.\n</p>\n\n<p><strong>Python example:</strong><br />\n<code>\nbody = {...}\nbody_string = json.dumps(<br />\n  body, sort_keys=True, indent=None, separators=(',', ': ') <br />\n).strip()\n</code>\n</p>\n\n<p>\nWhere `sort_keys=True` means that the output of dictionaries will be\nsorted by keys, `indent=None` means that the \"pretty-print\" is formatted\nin the most compact representation, without indentation and newlines.\n`separators=(',', ': ')` means that the item separator is comma (,) and\nthe key separator is a colon, followed by a space (: ).\n</p>\n\n<p>\nGet the digest by passing the app client secret (generated when creating a\nnew app) and the body string to `hmac.new`:\n<code>\ndigest = hmac.new(\n  client_secret.encode('utf-8'),\n  body_string.encode('utf-8'),\n  hashlib.sha256).digest()\n</code>\n</p>\n\n<p>\nReturn the digest in base64 encoded format:\n<code>\nsignature = base64.b64encode(digest).decode()\nrequest.set_header(\"X-PoT-Signature\", signature)\n</code>\n</p>\n\n<p><strong>JavaScript example:</strong><br />\n<code>\nconst jsSHA = require(\"jssha\");<br />\nconst stringify = require(\"json-stable-stringify\");<br />\nvar body = {...};<br />\nvar secret = client_secret;<br />\n// Sort keys and stringify. Note \"json-stable-stringify\" is used<br />\nlet bodyString = stringify(json);<br />\n// Item separator is comma (,) and the key separator is a colon,<br />\n// followed by a space (: )<br />\nbodyString = bodyString.replace(/([^\\\\](\\\\\\\\)*\"):/g, '$1: ');<br />\n// Escape non-ASCII characters<br />\nbodyString  = bodyString.replace(/[\\u007F-\\uFFFF]/g, (chr) => {<br />\n    return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)<br />\n});<br />\nvar shaObj = new jsSHA(\"SHA-256\", \"TEXT\");<br />\nshaObj.setHMACKey(secret, \"TEXT\");<br />\nshaObj.update(bodyString);<br />\nvar hmac = shaObj.getHMAC(\"B64\");<br />\ncontext.request.setHeader('x-pot-signature', hmac);\n</code>\n</p>\n\n<p>By using the library `json-stable-stringify` you get the keys sorted,\nand with the `replace()` you get the separators set correctly.\n</p>\n\n<p><strong>PHP example:</strong><br />\n<code>\n$body = [...];\nksort($body);\n$body_string = str_replace(\":\", \": \", json_encode($body));\n$signature = base64_encode(<br />\n  hash_hmac('sha256', $body_string, $client_secret, true)<br />\n);\n</code>\n</p>\n",
            "type": "string",
            "in": "header",
            "name": "X-Pot-Signature",
            "required": true
          },
          {
            "description": "The requesting app's JWT token. The token is generated when the\napp is created.\n",
            "type": "string",
            "in": "header",
            "name": "X-App-Token",
            "required": true
          },
          {
            "description": "The currently logged in user's OAuth bearer token. This is not mandatory,\nbut if passed, the token will be verified.\n",
            "type": "string",
            "in": "header",
            "name": "X-User-Token"
          },
          {
            "schema": {
              "example": {
                "@context": "https://standards.oftrust.net/v2/Context/DataProductParameters/Sensor",
                "timestamp": "2018-11-01T12:00:00+00:00",
                "productCode": "product-1",
                "parameters": {
                  "param-1": "Value",
                  "param-2": "Value"
                }
              },
              "$ref": "#/definitions/data-product-request"
            },
            "in": "body",
            "name": "body",
            "required": true
          }
        ]
      },
      "parameters": [
        {
          "type": "string",
          "in": "path",
          "name": "version",
          "required": true
        }
      ]
    }
  }
}
