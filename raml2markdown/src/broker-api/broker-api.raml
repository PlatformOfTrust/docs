#%RAML 1.0
---
title: Broker
version: v1
baseUri: https://api-sandbox.oftrust.net
mediaType: application/json
description: |
  The Broker API provides means to connect a service to a translator that will
  return desired data from different sources. The data broker does not mangle
  the data in any way, it only functions as a proxy between services and
  translators.
types:
  data-product-request:
    type: object
    properties:
      '@context?':
        description: A URL for the parameters context
        type: string
        example: https://standards.oftrust.net/v2/Context/DataProductParameters/Sensor
      timestamp:
        description: A timestamp in RFC3339 format
        type: string
        example: 2018-11-01T12:00:00+00:00
      productCode:
        description: The data product's product code
        type: string
        example: product-1
      parameters:
        description: Additional parameters to be sent to the translator
        type: object
        example: |
          {
            "param-1": "param-1 value",
            "param-2": "param-2 value"
          }
/broker/{version}/fetch-data-product:
  description: |
    Use a data product, e.g. request data from the external data source
    connected to the data product.
  post:
    description: |
      <p>
      Request data from an external data source defined by the data product. The data
      broker will validate the signature passed to the broker in the header
      `X-Pot-Signature`. See the parameter info for more info on how to generate
      this signature.
      </p>

      <p>
      Once the signature is validated, the request is passed on to the translator on
      the URL defined in the data product (`translatorUrl`).
      </p>

      <p>The data broker will generate it's own signature and pass it along in the
      `X-Pot-Signature` header. The translator must now validate that the request
      came from the data broker: (example in Python)<br />

      <code>
      body = {...}
      signature_value = request.headers.get("x-pot-signature")
      body_string = json.dumps(<br />
        body, sort_keys=True, indent=None, separators=(',', ': ')<br />
      ).strip()<br />
      rsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />
      key = rsa_algo.prepare_key(broker_public_key) <br />
      is_valid = rsa_algo.verify(body_string.encode("utf-8"), key, signature_value)
      </code>
      </p>

      <p>Once the translator has validated the signature and verified that the
      timestamp passed in the body is +/- 5 seconds, it can proceed to fetch the
      information from the third party data source, or wherever the data is hosted
      for this data product.
      </p>

      <p>Once the translator has got the needed data, it must sign the data with
      it's own private key (corresponding public key must be specified in the data
      product's `organizationPublicKeys` list) and return the data to the data broker.
      The data to be signed, is the `data` key in the response, e.g.
      <code>
      {<br />
        "@context": "https://standards.oftrust.net/v2/Context/Identity/Product/DataProduct/", <br />
        "data": data,  # this is the data that is signed.<br />
        "signature": {<br />
            "type": "RsaSignature2018",<br />
            "created": created_at,  # RFC 3339 timestamp<br />
            "creator": "https://url-to-public-key",  # Same URL as specified in the data product<br />
            "signatureValue": signature,<br />
        }<br />
      }
      </code>
      </p>

      <p>
      The signature itself is generated by adding a `__signed__` key to the data to
      be signed. It's the same RFC 3339 timestamp as when the signature was created.
      Example in Python:<br />
      <code>
      sign_data = copy(data)<br />
      sign_data["__signed__"] = created_at<br />
      sign_string = json.dumps(<br />
        sign_data, sort_keys=True, indent=None, separators=(',', ': ')<br />
      ).strip()<br />
      rsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />
      key = rsa_algo.prepare_key(translator_private_key) <br />
      signature = base64.b64encode(<br />
        rsa_algo.sign(sign_string.encode("utf-8"), key)<br />
      ).decode("utf-8")<br />
      </code>
      </p>

      <p>For more information read the header/parameter descriptions.</p>
    headers:
      X-Pot-Signature:
        description: |
          <p>
          A HMAC-SHA256 signature in `base64` encoded format.
          The signature is created from the request payload and the
          app's client secret.
          </p>

          <p><strong>Python example:</strong><br />
          <code>
          body = {...}
          body_string = json.dumps(<br />
            body, sort_keys=True, indent=None, separators=(',', ': ') <br />
          ).strip()
          </code>
          </p>

          <p>
          Where `sort_keys=True` means that the output of dictionaries will be
          sorted by keys, `indent=None` means that the "pretty-print" is formatted
          in the most compact representation, without indentation and newlines.
          `separators=(',', ': ')` means that the item separator is comma (,) and
          the key separator is a colon, followed by a space (: ).
          </p>

          <p>
          Get the digest by passing the app client secret (generated when creating a
          new app) and the body string to `hmac.new`:
          <code>
          digest = hmac.new(
            client_secret.encode('utf-8'),
            body_string.encode('utf-8'),
            hashlib.sha256).digest()
          </code>
          </p>

          <p>
          Return the digest in base64 encoded format:
          <code>
          signature = base64.b64encode(digest).decode()
          request.set_header("X-PoT-Signature", signature)
          </code>
          </p>

          <p><strong>JavaScript example:</strong><br />
          <code>
          const jsSHA = require("jssha");<br />
          const stringify = require("json-stable-stringify");<br />
          var body = {...};<br />
          var secret = client_secret;<br />
          // Sort keys and stringify. Note "json-stable-stringify" is used<br />
          let bodyString = stringify(json);<br />
          // Item separator is comma (,) and the key separator is a colon,<br />
          // followed by a space (: )<br />
          bodyString = bodyString.replace(/([^\\](\\\\)*"):/g, '$1: ');<br />
          // Escape non-ASCII characters<br />
          bodyString  = bodyString.replace(/[\u007F-\uFFFF]/g, (chr) => {<br />
              return "\\u" + ("0000" + chr.charCodeAt(0).toString(16)).substr(-4)<br />
          });<br />
          var shaObj = new jsSHA("SHA-256", "TEXT");<br />
          shaObj.setHMACKey(secret, "TEXT");<br />
          shaObj.update(bodyString);<br />
          var hmac = shaObj.getHMAC("B64");<br />
          context.request.setHeader('x-pot-signature', hmac);
          </code>
          </p>

          <p>By using the library `json-stable-stringify` you get the keys sorted,
          and with the `replace()` you get the separators set correctly.
          </p>

          <p><strong>PHP example:</strong><br />
          <code>
          $body = [...];
          ksort($body);
          $body_string = str_replace(":", ": ", json_encode($body));
          $signature = base64_encode(<br />
            hash_hmac('sha256', $body_string, $client_secret, true)<br />
          );
          </code>
          </p>

        type: string
        example: Ioma1gqOVFUBrXiziWS....CLqBG4vFozG3YgzPzillNip0=
      X-App-Token:
        description: |
          The requesting app's JWT token. The token is generated when the
          app is created.
        type: string
        example: eyJ0eXAiOiJJV1QiLcJhbgciOiJSUzI1NiJ9.eyJzY29w...VXs5fff
      X-User-Token?:
        description: |
          The currently logged in user's OAuth bearer token. This is not mandatory,
          but if passed, the token will be verified.
        type: string
        example: eyJ0eXAIOijKV1QiLcJGbGciOiJSUzI1NiJ9.eyJzY29w...DVs5aaf
    body:
      type: data-product-request
      example: |
        {
          "@context": "https://standards.oftrust.net/v2/Context/DataProductParameters/Sensor",
          "timestamp": "2018-11-01T12:00:00+00:00",
          "productCode": "product-1",
          "parameters": {
            "param-1": "Value",
            "param-2": "Value"
          }
        }
    responses:
      200:
        description: |
          <p><strong>Validating the signature from a translator</strong></p>

          <p>
          When you validate the signature returned from the translator, remember to
          `base64` decode the signature value from the response, and add the
          `__signed__` date to the payload
          before validating the signature, e.g:
          <code>
          signature_value = base64.b64decode(response["signature"]["signatureValue"]) <br />
          signature_payload = copy.copy(response["data"])  # to not modify the original data. <br />
          signature_payload["__signed__"] = signature_data["created"] <br />
          </code>
          </p>

          <p>When validating the signature, use the same way to get the
          string-version of the payload as when generating the `X-Pot-Signature`
          header. Then use the following approach to verify the signature
          returned:
          <code>
          payload_string = json.dumps(<br />
            signature_payload, sort_keys=True, indent=None, separators=(',', ': ')<br />
          ).strip()<br />
          rsa_algo = RSAAlgorithm(RSAAlgorithm.SHA256)<br />
          key = rsa_algo.prepare_key(public_key) <br />
          is_valid = rsa_algo.verify(payload_string.encode("utf-8"), key, signature_value)
          </code>
          </p>
        body:
          example: |
            {
              "@context": "<context url>",
              "data": {
                <response from translator>
              },
              "signature": {
                "type": "<signature type>",
                "created": "<RFC3339>",
                "creator": "<public key URL>",
                "signatureValue": "..."
              }
            }
      403:
        body:
          description: |
            You don't have permissions to consume this data product!
          example: |
              {
                "error": {
                  "status": 403,
                  "message": "You don't have permissions to consume this data product!"
                }
              }
      422:
        body:
          description: |
            Missing data for required field.
          example: |
            {
              "error": {
                "status": 422,
                "message": {
                  "mandatoryParameter": [
                    "Missing data for required field."
                  ]
                }
              }
            }
      500:
        body:
          description: |
            The data returned from the translator cannot be read or parsed.
          example: |
              {
                "error": {
                  "status": 500,
                  "message": "Could not parse response from translator"
                }
              }
      502:
        body:
          description: |
            Error encountered in the external service.
          examples:
            Any translator error with Content-Type `text/html` or `text/plain`: |
              {
                "error": {
                  "status": 502,
                  "message": "External translator returns an invalid response.",
                  "translatorResponse": {
                    "status": 422,
                    "data": "Invalid parameters"
                  }
                }
              }
            Any translator error with Content-Type `application/json`: |
              {
                "error": {
                  "status": 502,
                  "message": "External translator returns an invalid response.",
                  "translatorResponse": {
                    "status": 422,
                    "data": {
                      "dataFromTranslatorAsIs": [
                        1,
                        2,
                        3
                      ]
                    }
                  }
                }
              }
            Any translator error with Content-Type is something else than defined in previous examples: |
              {
                "error": {
                  "status": 502,
                  "message": "External translator returns an invalid response.",
                  "translatorResponse": {
                    "status": 422
                  }
                }
              }

      504:
        body:
          description: |
            The translator takes too long to respond
          example: |
            {
              "error": {
                "status": 504,
                "message": "External translator takes too long to respond"
              }
            }
